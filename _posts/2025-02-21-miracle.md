---
layout: post
title: "偶然の産物"
date: 2025-02-21 23:54
category: programming FetutEngine
author: ark231
tags: []
---
うまく行く方向に間違っていた。  
<!-- more -->
## 状況
描画エンジンのインデックスバッファの型が間違っていて、本来は16bit符号無し整数の配列になるべきところを32bit浮動小数点数の配列にしてしまっていた。
(頂点バッファをコピペして変え忘れたものと思われる。)  
この部分は実装してからしばらく経っているが、今日気づくまで全く描画に問題は生じていなかった。最初はなぜ動いていたのか全く見当がつかなかった。
インデックスは整数でなければならないからだ。「5番目の頂点」だとか「350番目の頂点」だとかは存在するが、「3.14番目の頂点」だとか「0.02番目の頂点」
なんてものは存在しない。当然GPUは整数のインデックスしかサポートしないだろうから、浮動小数点数を渡しても同じビット列の整数として解釈して
範囲外アクセスを起こしてクラッシュするはずである。そうならなかったとしても頂点の順番がめちゃくちゃになって到底悲惨なことになっていたはずである。  
しかしながら、そのようなことは一切発生せず想定通りの物体が描画されていた。  

## 原因
コードを検討したらなぜ動いていたのかがはっきりした。  
1. 初期化の方法が良かった  
`std::vector`を使っていたのだが、glTFから読み込む都合上`vector::resize()`した後`vector::data()`で得た生ポインタに直接`memcpy`して初期化していた。  
    1. サイズが安全な方向にズレていた  
    `resize()`の引数にglTFから読み取った要素数を入れていたため、`sizeof(float)*要素数`バイトの領域が確保されていた。
    今回、運よく`sizeof(float) > sizeof(uint16_t)`だったので必要以上の容量を確保するだけですんでおり、範囲外アクセスが発生せずにすんでいた。
    1. 値が破壊されなかった  
    そもそも、`memcpy`していたおかげで、ビット列が破壊されずそのまま保存されていた。浮動小数点数として解釈したら多分意味をなさない値の列に
    なっていたのだろうが、後述するようにビット列が重要だったため運が良かった。
1. GPUへの渡し方が良かった  
GPUへバッファのデータを転送するときには、正しく16bit符号無し整数であると伝えていた。送信時は、確保した転送バッファにこれまた`memcpy`して
値を入れていた。このサイズは`vector::size()*sizeof(float)`であったため、これまた過剰であり、足りなくてオブジェクトが途切れるという自体が
発生し得ない状態になっていた。
1. 描画コマンドの引数が良かった  
描画時には、描画するインデックスの数を指定する必要があるのだが、ここに`vector::size()`の結果を指定していた。そして、これは初期化時に
`resize()`したときにglTFから読み取った正しい数になっていたので、描画時は正しい数のインデックスを描画しており、今回のミスによる
余分な(そして未初期化な)領域を読み込むことがなく、アーティファクトが発生せずに済んでいた。

## 結論
まとめると、`vector`をただの可変長のバイト列として使っていて、今回のミスでは必要以上の領域を確保してしまう以外の副作用が生じなかったため
問題が発生しなかったということである。  
ちなみに、なぜこの問題に気がついたかというと、デバッグのためglTFから読み込むのではなくプログラム上でオブジェクトを生成するコードを実装していて、
手動でバッファをセットする必要があったからである。  
インデックスバッファに値を書き込むために型を確認して、「なんでインデックスが浮動小数点数になってるんだ？」となったわけである。この場合は
`vector`をバイト列ではなく型付の配列として扱うため、要素型があっていないとうまく動かないわけである。

